"use strict";(self.webpackChunkdoeks_website=self.webpackChunkdoeks_website||[]).push([[3155],{3905:(e,a,t)=>{t.d(a,{Zo:()=>u,kt:()=>k});var n=t(7294);function r(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function o(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function s(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?o(Object(t),!0).forEach((function(a){r(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function l(e,a){if(null==e)return{};var t,n,r=function(e,a){if(null==e)return{};var t,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)t=o[n],a.indexOf(t)>=0||(r[t]=e[t]);return r}(e,a);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)t=o[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var i=n.createContext({}),p=function(e){var a=n.useContext(i),t=a;return e&&(t="function"==typeof e?e(a):s(s({},a),e)),t},u=function(e){var a=p(e.components);return n.createElement(i.Provider,{value:a},e.children)},d="mdxType",c={inlineCode:"code",wrapper:function(e){var a=e.children;return n.createElement(n.Fragment,{},a)}},m=n.forwardRef((function(e,a){var t=e.components,r=e.mdxType,o=e.originalType,i=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=p(t),m=r,k=d["".concat(i,".").concat(m)]||d[m]||c[m]||o;return t?n.createElement(k,s(s({ref:a},u),{},{components:t})):n.createElement(k,s({ref:a},u))}));function k(e,a){var t=arguments,r=a&&a.mdxType;if("string"==typeof e||r){var o=t.length,s=new Array(o);s[0]=m;var l={};for(var i in a)hasOwnProperty.call(a,i)&&(l[i]=a[i]);l.originalType=e,l[d]="string"==typeof e?e:r,s[1]=l;for(var p=2;p<o;p++)s[p]=t[p];return n.createElement.apply(null,s)}return n.createElement.apply(null,t)}m.displayName="MDXCreateElement"},5162:(e,a,t)=>{t.d(a,{Z:()=>s});var n=t(7294),r=t(6010);const o={tabItem:"tabItem_Ymn6"};function s(e){let{children:a,hidden:t,className:s}=e;return n.createElement("div",{role:"tabpanel",className:(0,r.Z)(o.tabItem,s),hidden:t},a)}},4866:(e,a,t)=>{t.d(a,{Z:()=>S});var n=t(7462),r=t(7294),o=t(6010),s=t(2466),l=t(6550),i=t(1980),p=t(7392),u=t(12);function d(e){return function(e){return r.Children.map(e,(e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:a}=e;return!!a&&"object"==typeof a&&"value"in a}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}(e).map((e=>{let{props:{value:a,label:t,attributes:n,default:r}}=e;return{value:a,label:t,attributes:n,default:r}}))}function c(e){const{values:a,children:t}=e;return(0,r.useMemo)((()=>{const e=a??d(t);return function(e){const a=(0,p.l)(e,((e,a)=>e.value===a.value));if(a.length>0)throw new Error(`Docusaurus error: Duplicate values "${a.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[a,t])}function m(e){let{value:a,tabValues:t}=e;return t.some((e=>e.value===a))}function k(e){let{queryString:a=!1,groupId:t}=e;const n=(0,l.k6)(),o=function(e){let{queryString:a=!1,groupId:t}=e;if("string"==typeof a)return a;if(!1===a)return null;if(!0===a&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:a,groupId:t});return[(0,i._X)(o),(0,r.useCallback)((e=>{if(!o)return;const a=new URLSearchParams(n.location.search);a.set(o,e),n.replace({...n.location,search:a.toString()})}),[o,n])]}function h(e){const{defaultValue:a,queryString:t=!1,groupId:n}=e,o=c(e),[s,l]=(0,r.useState)((()=>function(e){let{defaultValue:a,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(a){if(!m({value:a,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${a}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return a}const n=t.find((e=>e.default))??t[0];if(!n)throw new Error("Unexpected error: 0 tabValues");return n.value}({defaultValue:a,tabValues:o}))),[i,p]=k({queryString:t,groupId:n}),[d,h]=function(e){let{groupId:a}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(a),[n,o]=(0,u.Nk)(t);return[n,(0,r.useCallback)((e=>{t&&o.set(e)}),[t,o])]}({groupId:n}),f=(()=>{const e=i??d;return m({value:e,tabValues:o})?e:null})();(0,r.useLayoutEffect)((()=>{f&&l(f)}),[f]);return{selectedValue:s,selectValue:(0,r.useCallback)((e=>{if(!m({value:e,tabValues:o}))throw new Error(`Can't select invalid tab value=${e}`);l(e),p(e),h(e)}),[p,h,o]),tabValues:o}}var f=t(2389);const g={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function b(e){let{className:a,block:t,selectedValue:l,selectValue:i,tabValues:p}=e;const u=[],{blockElementScrollPositionUntilNextRender:d}=(0,s.o5)(),c=e=>{const a=e.currentTarget,t=u.indexOf(a),n=p[t].value;n!==l&&(d(a),i(n))},m=e=>{let a=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{const t=u.indexOf(e.currentTarget)+1;a=u[t]??u[0];break}case"ArrowLeft":{const t=u.indexOf(e.currentTarget)-1;a=u[t]??u[u.length-1];break}}a?.focus()};return r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.Z)("tabs",{"tabs--block":t},a)},p.map((e=>{let{value:a,label:t,attributes:s}=e;return r.createElement("li",(0,n.Z)({role:"tab",tabIndex:l===a?0:-1,"aria-selected":l===a,key:a,ref:e=>u.push(e),onKeyDown:m,onClick:c},s,{className:(0,o.Z)("tabs__item",g.tabItem,s?.className,{"tabs__item--active":l===a})}),t??a)})))}function y(e){let{lazy:a,children:t,selectedValue:n}=e;const o=(Array.isArray(t)?t:[t]).filter(Boolean);if(a){const e=o.find((e=>e.props.value===n));return e?(0,r.cloneElement)(e,{className:"margin-top--md"}):null}return r.createElement("div",{className:"margin-top--md"},o.map(((e,a)=>(0,r.cloneElement)(e,{key:a,hidden:e.props.value!==n}))))}function v(e){const a=h(e);return r.createElement("div",{className:(0,o.Z)("tabs-container",g.tabList)},r.createElement(b,(0,n.Z)({},e,a)),r.createElement(y,(0,n.Z)({},e,a)))}function S(e){const a=(0,f.Z)();return r.createElement(v,(0,n.Z)({key:String(a)},e))}},769:(e,a,t)=>{t.d(a,{Z:()=>m});var n=t(7294),r=t(5697),o=t.n(r),s=t(6010);const l="collapsibleContent_q3kw",i="header_QCEw",p="icon_PckA",u="content_qLC1",d="expanded_iGsi";function c(e){let{children:a,header:t}=e;const[r,o]=(0,n.useState)(!1);return n.createElement("div",{className:l},n.createElement("div",{className:(0,s.Z)(i,{[d]:r}),onClick:()=>{o(!r)}},t,n.createElement("span",{className:(0,s.Z)(p,{[d]:r})})),r&&n.createElement("div",{className:u},a))}c.propTypes={children:o().node.isRequired,header:o().node.isRequired};const m=c},9998:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>d,contentTitle:()=>p,default:()=>h,frontMatter:()=>i,metadata:()=>u,toc:()=>c});var n=t(7462),r=(t(7294),t(3905)),o=t(4866),s=t(5162),l=t(769);const i={sidebar_position:2,sidebar_label:"Spark Operator with YuniKorn"},p="Spark Operator with YuniKorn",u={unversionedId:"data-analytics/spark-operator-yunikorn",id:"data-analytics/spark-operator-yunikorn",title:"Spark Operator with YuniKorn",description:"Introduction",source:"@site/docs/data-analytics/spark-operator-yunikorn.md",sourceDirName:"data-analytics",slug:"/data-analytics/spark-operator-yunikorn",permalink:"/data-on-eks/docs/data-analytics/spark-operator-yunikorn",draft:!1,editUrl:"https://github.com/awslabs/data-on-eks/blob/main/website/docs/data-analytics/spark-operator-yunikorn.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2,sidebar_label:"Spark Operator with YuniKorn"},sidebar:"docs",previous:{title:"Introduction",permalink:"/data-on-eks/docs/data-analytics/"},next:{title:"Observability Spark on EKS",permalink:"/data-on-eks/docs/data-analytics/observability-spark-on-eks"}},d={},c=[{value:"Introduction",id:"introduction",level:2},{value:"Prerequisites",id:"prerequisites",level:3},{value:"Deploy",id:"deploy",level:3},{value:"NVMe Ephemeral SSD disk for Spark shuffle storage",id:"nvme-ephemeral-ssd-disk-for-spark-shuffle-storage",level:2},{value:"EBS Dynamic PVC for shuffle storage",id:"ebs-dynamic-pvc-for-shuffle-storage",level:2},{value:"Apache YuniKorn Gang Scheduling with NVMe based SSD disk for shuffle storage",id:"apache-yunikorn-gang-scheduling-with-nvme-based-ssd-disk-for-shuffle-storage",level:2},{value:"NVMe Ephemeral SSD disk for Spark shuffle storage",id:"nvme-ephemeral-ssd-disk-for-spark-shuffle-storage-1",level:2},{value:"EBS Dynamic PVC for shuffle storage",id:"ebs-dynamic-pvc-for-shuffle-storage-1",level:2},{value:"Apache YuniKorn Gang Scheduling with NVMe based SSD disk for shuffle storage",id:"apache-yunikorn-gang-scheduling-with-nvme-based-ssd-disk-for-shuffle-storage-1",level:2}],m={toc:c},k="wrapper";function h(e){let{components:a,...i}=e;return(0,r.kt)(k,(0,n.Z)({},m,i,{components:a,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"spark-operator-with-yunikorn"},"Spark Operator with YuniKorn"),(0,r.kt)("h2",{id:"introduction"},"Introduction"),(0,r.kt)("p",null,"The EKS Cluster design for the Data on EKS blueprint is optimized for running Spark applications with Spark Operator and Apache YuniKorn as the batch scheduler. This blueprint shows both options of leveraging Cluster Autoscaler and Karpenter for Spark Workloads. AWS for FluentBit is employed for logging, and a combination of Prometheus, Amazon Managed Prometheus, and open source Grafana are used for observability. Additionally, the Spark History Server Live UI is configured for monitoring running Spark jobs through an NLB and NGINX ingress controller."),(0,r.kt)(l.Z,{header:(0,r.kt)("h2",null,(0,r.kt)("span",null,"Spark workloads with Karpenter")),mdxType:"CollapsibleContent"},(0,r.kt)("p",null,"The first option presents leverages Karpenter as the autoscaler, eliminating the need for Managed Node Groups and Cluster Autoscaler. In this design, Karpenter and its provisioner are responsible for creating both On-Demand and Spot instances, dynamically selecting instance types based on user demands. Karpenter offers improved performance compared to Cluster Autoscaler, with more efficient node scaling and faster response times. Karpenter's key features include its ability to scale from zero, optimizing resource utilization and reducing costs when there is no demand for resources. Additionally, Karpenter supports multiple provisioners, allowing for greater flexibility in defining the required infrastructure for different workload types, such as compute, memory, and GPU-intensive tasks. Furthermore, Karpenter integrates seamlessly with Kubernetes, providing automatic, real-time adjustments to the cluster size based on observed workloads and scaling events. This enables a more efficient and cost-effective EKS cluster design that adapts to the ever-changing demands of Spark applications and other workloads."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"img.png",src:t(3329).Z,width:"4194",height:"2705"})),(0,r.kt)(o.Z,{mdxType:"Tabs"},(0,r.kt)(s.Z,{value:"spark-memory-optimized",label:"spark-memory-optimized",mdxType:"TabItem"},(0,r.kt)("p",null,"In this tutorial, you will use Karpenter provisioner that uses memory optimized instances. This template uses the AWS Node template with Userdata."),(0,r.kt)("details",null,(0,r.kt)("summary",null," To view Karpenter provisioner for memory optimized instances, Click to toggle content!"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'apiVersion: karpenter.sh/v1alpha5\nkind: Provisioner\nmetadata:\n  name: spark-memory-optimized\n  namespace: karpenter\nspec:\n  kubeletConfiguration:\n    containerRuntime: containerd\n#    podsPerCore: 2\n#    maxPods: 20\n  requirements:\n    - key: "topology.kubernetes.io/zone"\n      operator: In\n      values: [${azs}b] #Update the correct region and zone\n    - key: "karpenter.sh/capacity-type"\n      operator: In\n      values: ["spot", "on-demand"]\n    - key: "node.kubernetes.io/instance-type" #If not included, all instance types are considered\n      operator: In\n      values: ["r5d.4xlarge","r5d.8xlarge","r5d.12xlarge"] # 2 NVMe disk\n    - key: "kubernetes.io/arch"\n      operator: In\n      values: ["amd64"]\n  limits:\n    resources:\n      cpu: 1000\n  providerRef: # optional, recommended to use instead of `provider`\n    name: spark-memory-optimized\n  labels:\n    type: karpenter\n    provisioner: spark-memory-optimized\n    NodeGroupType: SparkMemoryOptimized\n  taints:\n    - key: spark-memory-optimized\n      value: \'true\'\n      effect: NoSchedule\n  ttlSecondsAfterEmpty: 120 # optional, but never scales down if not set\n\n---\napiVersion: karpenter.k8s.aws/v1alpha1\nkind: AWSNodeTemplate\nmetadata:\n  name: spark-memory-optimized\n  namespace: karpenter\nspec:\n  blockDeviceMappings:\n    - deviceName: /dev/xvda\n      ebs:\n        volumeSize: 100Gi\n        volumeType: gp3\n        encrypted: true\n        deleteOnTermination: true\n  metadataOptions:\n    httpEndpoint: enabled\n    httpProtocolIPv6: disabled\n    httpPutResponseHopLimit: 2\n    httpTokens: required\n  subnetSelector:\n    Name: "${eks_cluster_id}-private*"        # Name of the Subnets to spin up the nodes\n  securityGroupSelector:                      # required, when not using launchTemplate\n    Name: "${eks_cluster_id}-node*"           # name of the SecurityGroup to be used with Nodes\n  #  instanceProfile: ""      # optional, if already set in controller args\n  #RAID0 config example\n  userData: |\n    MIME-Version: 1.0\n    Content-Type: multipart/mixed; boundary="BOUNDARY"\n\n    --BOUNDARY\n    Content-Type: text/x-shellscript; charset="us-ascii"\n\n    #!/bin/bash\n    echo "Running a custom user data script"\n    set -ex\n    yum install mdadm -y\n\n    IDX=1\n    DEVICES=$(lsblk -o NAME,TYPE -dsn | awk \'/disk/ {print $1}\')\n\n    DISK_ARRAY=()\n\n    for DEV in $DEVICES\n    do\n      DISK_ARRAY+=("/dev/$${DEV}")\n    done\n\n    DISK_COUNT=$${#DISK_ARRAY[@]}\n\n    if [ $${DISK_COUNT} -eq 0 ]; then\n      echo "No SSD disks available. No further action needed."\n    else\n      if [ $${DISK_COUNT} -eq 1 ]; then\n        TARGET_DEV=$${DISK_ARRAY[0]}\n        mkfs.xfs $${TARGET_DEV}\n      else\n        mdadm --create --verbose /dev/md0 --level=0 --raid-devices=$${DISK_COUNT} $${DISK_ARRAY[@]}\n        mkfs.xfs /dev/md0\n        TARGET_DEV=/dev/md0\n      fi\n\n      mkdir -p /local1\n      echo $${TARGET_DEV} /local1 xfs defaults,noatime 1 2 >> /etc/fstab\n      mount -a\n      /usr/bin/chown -hR +999:+1000 /local1\n    fi\n\n    --BOUNDARY--\n\n  tags:\n    InstanceType: "spark-memory-optimized"    # optional, add tags for your own use\n\n'))),(0,r.kt)("p",null,"To run Spark Jobs that can use this provisioner, you need to submit your jobs by adding ",(0,r.kt)("inlineCode",{parentName:"p"},"tolerations")," to your pod templates"),(0,r.kt)("p",null,"For example,"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'spec:\n  tolerations:\n    - key: "spark-memory-optimized"\n      operator: "Exists"\n      effect: "NoSchedule"\n'))),(0,r.kt)(s.Z,{value:"spark-graviton-memory-optimized",label:"spark-graviton-memory-optimized",mdxType:"TabItem"},(0,r.kt)("p",null,"In this yaml, you will use Karpenter provisioner that uses Graviton memory optimized instances. This template uses the AWS Node template with Userdata."),(0,r.kt)("details",null,(0,r.kt)("summary",null," To view Karpenter provisioner for Graviton memory optimized instances, Click to toggle content!"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'apiVersion: karpenter.sh/v1alpha5\nkind: Provisioner\nmetadata:\n  name: spark-graviton-memory-optimized\n  namespace: karpenter\nspec:\n  kubeletConfiguration:\n    containerRuntime: containerd\n#    podsPerCore: 2\n#    maxPods: 20\n  requirements:\n    - key: "topology.kubernetes.io/zone"\n      operator: In\n      values: [${azs}b] #Update the correct region and zone\n    - key: "karpenter.sh/capacity-type"\n      operator: In\n      values: ["spot", "on-demand"]\n    - key: "node.kubernetes.io/instance-type" #If not included, all instance types are considered\n      operator: In\n      values: ["r6gd.4xlarge", "r6gd.8xlarge"] # 2 NVMe disk\n    - key: "kubernetes.io/arch"\n      operator: In\n      values: ["arm64"]\n  limits:\n    resources:\n      cpu: 1000\n  providerRef: # optional, recommended to use instead of `provider`\n    name: spark-graviton-memory-optimized\n  labels:\n    type: karpenter\n    provisioner: spark-graviton-memory-optimized\n    NodeGroupType: SparkGravitonMemoryOptimized\n  taints:\n    - key: spark-graviton-memory-optimized\n      value: \'true\'\n      effect: NoSchedule\n  ttlSecondsAfterEmpty: 120 # optional, but never scales down if not set\n\n---\napiVersion: karpenter.k8s.aws/v1alpha1\nkind: AWSNodeTemplate\nmetadata:\n  name: spark-graviton-memory-optimized\n  namespace: karpenter\nspec:\n  blockDeviceMappings:\n    - deviceName: /dev/xvda\n      ebs:\n        volumeSize: 200Gi\n        volumeType: gp3\n        encrypted: true\n        deleteOnTermination: true\n  metadataOptions:\n    httpEndpoint: enabled\n    httpProtocolIPv6: disabled\n    httpPutResponseHopLimit: 2\n    httpTokens: required\n  subnetSelector:\n    Name: "${eks_cluster_id}-private*"        # Name of the Subnets to spin up the nodes\n  securityGroupSelector:                      # required, when not using launchTemplate\n    Name: "${eks_cluster_id}-node*"           # name of the SecurityGroup to be used with Nodes\n  #  instanceProfile: ""      # optional, if already set in controller args\n  #RAID0 config example\n  userData: |\n    MIME-Version: 1.0\n    Content-Type: multipart/mixed; boundary="BOUNDARY"\n\n    --BOUNDARY\n    Content-Type: text/x-shellscript; charset="us-ascii"\n\n    #!/bin/bash\n    echo "Running a custom user data script"\n    set -ex\n    yum install mdadm -y\n\n    DEVICES=$(lsblk -o NAME,TYPE -dsn | awk \'/disk/ {print $1}\')\n\n    DISK_ARRAY=()\n\n    for DEV in $DEVICES\n    do\n      DISK_ARRAY+=("/dev/$${DEV}")\n    done\n\n    DISK_COUNT=$${#DISK_ARRAY[@]}\n\n    if [ $${DISK_COUNT} -eq 0 ]; then\n      echo "No SSD disks available. No further action needed."\n    else\n      if [ $${DISK_COUNT} -eq 1 ]; then\n        TARGET_DEV=$${DISK_ARRAY[0]}\n        mkfs.xfs $${TARGET_DEV}\n      else\n        mdadm --create --verbose /dev/md0 --level=0 --raid-devices=$${DISK_COUNT} $${DISK_ARRAY[@]}\n        mkfs.xfs /dev/md0\n        TARGET_DEV=/dev/md0\n      fi\n\n      mkdir -p /local1\n      echo $${TARGET_DEV} /local1 xfs defaults,noatime 1 2 >> /etc/fstab\n      mount -a\n      /usr/bin/chown -hR +999:+1000 /local1\n    fi\n\n    --BOUNDARY--\n\n  tags:\n    InstanceType: "spark-graviton-memory-optimized"    # optional, add tags for your own use\n\n'))),(0,r.kt)("p",null,"To run Spark Jobs that can use this provisioner, you need to submit your jobs by adding ",(0,r.kt)("inlineCode",{parentName:"p"},"tolerations")," to your pod templates"),(0,r.kt)("p",null,"For example,"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'spec:\n  tolerations:\n    - key: "spark-graviton-memory-optimized"\n      operator: "Exists"\n      effect: "NoSchedule"\n'))))),(0,r.kt)(l.Z,{header:(0,r.kt)("h2",null,(0,r.kt)("span",null,"Spark workloads with ClusterAutoscaler and Managed NodeGroups")),mdxType:"CollapsibleContent"},(0,r.kt)("p",null,"The second option leverages Cluster Autoscaler as an alternative design utilizing Cluster Autoscaler with Managed Node Groups for scaling Spark workloads. Spark Driver pods are scaled using On-Demand Node Groups, while Spot Node Groups are utilized for Executor pods. The Cluster Autoscaler ensures that the EKS cluster size adapts to the demands of the Spark applications, while Managed Node Groups provide the underlying infrastructure for the Driver and Executor pods. This design allows for a seamless scaling experience, adjusting resources based on workload requirements while minimizing costs."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"img.png",src:t(1824).Z,width:"1398",height:"834"}))),(0,r.kt)(l.Z,{header:(0,r.kt)("h2",null,(0,r.kt)("span",null,"NVMe SSD Instance Storage for Spark Shuffle data")),mdxType:"CollapsibleContent"},(0,r.kt)("p",null,'It is important to note that both options in the EKS Cluster design utilize NVMe SSD instance storage for each node to serve as shuffle storage for Spark workloads. These high-performance storage options are available with all "d" type instances.'),(0,r.kt)("p",null,"The use of NVMe SSD instance storage as shuffle storage for Spark brings numerous advantages. First, it provides low-latency and high-throughput data access, significantly improving Spark's shuffle performance. This results in faster job completion times and enhanced overall application performance. Second, the use of local SSD storage reduces the reliance on remote storage systems, such as EBS volumes, which can become a bottleneck during shuffle operations. This also reduces the costs associated with provisioning and managing additional EBS volumes for shuffle data. Finally, by leveraging NVMe SSD storage, the EKS cluster design offers better resource utilization and increased performance, allowing Spark applications to process larger datasets and tackle more complex analytics workloads more efficiently. This optimized storage solution ultimately contributes to a more scalable and cost-effective EKS cluster tailored for running Spark workloads on Kubernetes.")),(0,r.kt)(l.Z,{header:(0,r.kt)("h2",null,(0,r.kt)("span",null,"Spark Operator")),mdxType:"CollapsibleContent"},(0,r.kt)("p",null,"The Kubernetes Operator for Apache Spark aims to make specifying and running Spark applications as easy and idiomatic as running other workloads on Kubernetes."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"a SparkApplication controller that watches events of creation, updates, and deletion of SparkApplication objects and acts on the watch events,"),(0,r.kt)("li",{parentName:"ul"},"a submission runner that runs spark-submit for submissions received from the controller,"),(0,r.kt)("li",{parentName:"ul"},"a Spark pod monitor that watches for Spark pods and sends pod status updates to the controller,"),(0,r.kt)("li",{parentName:"ul"},"a Mutating Admission Webhook that handles customizations for Spark driver and executor pods based on the annotations on the pods added by the controller,"),(0,r.kt)("li",{parentName:"ul"},"and also a command-line tool named sparkctl for working with the operator.")),(0,r.kt)("p",null,"The following diagram shows how different components of Spark Operator add-on interact and work together."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"img.png",src:t(5394).Z,width:"960",height:"540"}))),(0,r.kt)(l.Z,{header:(0,r.kt)("h2",null,(0,r.kt)("span",null,"Deploying the Solution")),mdxType:"CollapsibleContent"},(0,r.kt)("p",null,"In this ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/awslabs/data-on-eks/tree/main/analytics/terraform/spark-k8s-operator"},"example"),", you will provision the following resources required to run Spark Jobs with open source Spark Operator and Apache YuniKorn."),(0,r.kt)("p",null,"This example deploys an EKS Cluster running the Spark K8s Operator into a new VPC."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Creates a new sample VPC, 2 Private Subnets and 2 Public Subnets"),(0,r.kt)("li",{parentName:"ul"},"Creates Internet gateway for Public Subnets and NAT Gateway for Private Subnets"),(0,r.kt)("li",{parentName:"ul"},"Creates EKS Cluster Control plane with public endpoint (for demo reasons only) with core managed node group, on-demand node group and Spot node group for Spark workloads."),(0,r.kt)("li",{parentName:"ul"},"Deploys Metrics server, Cluster Autoscaler, Spark-k8s-operator, Apache Yunikorn, Karpenter, Grafana, AMP and Prometheus server.")),(0,r.kt)("h3",{id:"prerequisites"},"Prerequisites"),(0,r.kt)("p",null,"Ensure that you have installed the following tools on your machine."),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("a",{parentName:"li",href:"https://docs.aws.amazon.com/cli/latest/userguide/install-cliv2.html"},"aws cli")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("a",{parentName:"li",href:"https://Kubernetes.io/docs/tasks/tools/"},"kubectl")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("a",{parentName:"li",href:"https://learn.hashicorp.com/tutorials/terraform/install-cli"},"terraform"))),(0,r.kt)("h3",{id:"deploy"},"Deploy"),(0,r.kt)("p",null,"Clone the repository"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"git clone https://github.com/awslabs/data-on-eks.git\n")),(0,r.kt)("p",null,"Navigate into one of the example directories and run ",(0,r.kt)("inlineCode",{parentName:"p"},"install.sh")," script"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"cd data-on-eks/analytics/terraform/spark-k8s-operator\nchmod +x install.sh\n./install.sh\n"))),(0,r.kt)(l.Z,{header:(0,r.kt)("h2",null,(0,r.kt)("span",null,"Execute Sample Spark job with Karpenter")),mdxType:"CollapsibleContent"},(0,r.kt)("p",null,"Navigate to example directory and submit the Spark job."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"cd data-on-eks/analytics/terraform/spark-k8s-operator/examples/karpenter\nkubectl apply -f pyspark-pi-job.yaml\n")),(0,r.kt)("p",null,"Monitor the job status using the below command.\nYou should see the new nodes triggered by the karpenter and the YuniKorn will schedule one driver pod and 2 executor pods on this node."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl get pods -n spark-team-a -w\n")),(0,r.kt)("p",null,"You can try the following examples to leverage multiple Karpenter provisioners, EBS as Dynamic PVC instead of SSD and YuniKorn Gang Scheduling."),(0,r.kt)("h2",{id:"nvme-ephemeral-ssd-disk-for-spark-shuffle-storage"},"NVMe Ephemeral SSD disk for Spark shuffle storage"),(0,r.kt)("p",null,"Example PySpark job that uses NVMe based ephemeral SSD disk for Driver and Executor shuffle storage"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"  cd analytics/terraform/spark-k8s-operator/examples/karpenter/nvme-ephemeral-storage/\n")),(0,r.kt)("p",null,"Update the variables in Shell script and execute"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"  ./taxi-trip-execute.sh\n")),(0,r.kt)("p",null,"Update YAML file and run the below command"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"  kubectl apply -f nvme-ephemeral-storage.yaml\n")),(0,r.kt)("h2",{id:"ebs-dynamic-pvc-for-shuffle-storage"},"EBS Dynamic PVC for shuffle storage"),(0,r.kt)("p",null,"Example PySpark job that uses EBS ON_DEMAND volumes using Dynamic PVCs for Driver and Executor shuffle storage"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"  cd analytics/terraform/spark-k8s-operator/examples/karpenter/ebs-storage-dynamic-pvc/\n")),(0,r.kt)("p",null,"Update the variables in Shell script and execute"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"  ./taxi-trip-execute.sh\n")),(0,r.kt)("p",null,"Update YAML file and run the below command"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"  kubectl apply -f ebs-storage-dynamic-pvc.yaml\n")),(0,r.kt)("h2",{id:"apache-yunikorn-gang-scheduling-with-nvme-based-ssd-disk-for-shuffle-storage"},"Apache YuniKorn Gang Scheduling with NVMe based SSD disk for shuffle storage"),(0,r.kt)("p",null,"Gang Scheduling Spark jobs using Apache YuniKorn and Spark Operator"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"  cd analytics/terraform/spark-k8s-operator/examples/karpenter/nvme-yunikorn-gang-scheduling/\n")),(0,r.kt)("p",null,"Update the variables in Shell script and execute"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"  ./taxi-trip-execute.sh\n")),(0,r.kt)("p",null,"Update YAML file and run the below command"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"  kubectl apply -f nvme-storage-yunikorn-gang-scheduling.yaml\n"))),(0,r.kt)(l.Z,{header:(0,r.kt)("h2",null,(0,r.kt)("span",null,"Execute Sample Spark job with Cluster Autoscaler and Managed Node groups")),mdxType:"CollapsibleContent"},(0,r.kt)("p",null,"Navigate to example directory and submit the Spark job."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"cd data-on-eks/analytics/terraform/spark-k8s-operator/examples/cluster-autoscaler\nkubectl apply -f pyspark-pi-job.yaml\n")),(0,r.kt)("p",null,"Monitor the job status using the below command.\nYou should see the new nodes triggered by the karpenter and the YuniKorn will schedule one driver pod and 2 executor pods on this node."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl get pods -n spark-team-a -w\n")),(0,r.kt)("h2",{id:"nvme-ephemeral-ssd-disk-for-spark-shuffle-storage-1"},"NVMe Ephemeral SSD disk for Spark shuffle storage"),(0,r.kt)("p",null,"Example PySpark job that uses NVMe based ephemeral SSD disk for Driver and Executor shuffle storage"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"  cd analytics/terraform/spark-k8s-operator/examples/cluster-autoscaler/nvme-ephemeral-storage\n")),(0,r.kt)("p",null,"Update the variables in Shell script and execute"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"  ./taxi-trip-execute.sh\n")),(0,r.kt)("p",null,"Update YAML file and run the below command"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"  kubectl apply -f nvme-ephemeral-storage.yaml\n")),(0,r.kt)("h2",{id:"ebs-dynamic-pvc-for-shuffle-storage-1"},"EBS Dynamic PVC for shuffle storage"),(0,r.kt)("p",null,"Example PySpark job that uses EBS ON_DEMAND volumes using Dynamic PVCs for Driver and Executor shuffle storage"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"  cd analytics/terraform/spark-k8s-operator/examples/cluster-autoscaler/ebs-storage-dynamic-pvc\n")),(0,r.kt)("p",null,"Update the variables in Shell script and execute"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"  ./taxi-trip-execute.sh\n")),(0,r.kt)("p",null,"Update YAML file and run the below command"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"  kubectl apply -f ebs-storage-dynamic-pvc.yaml\n")),(0,r.kt)("h2",{id:"apache-yunikorn-gang-scheduling-with-nvme-based-ssd-disk-for-shuffle-storage-1"},"Apache YuniKorn Gang Scheduling with NVMe based SSD disk for shuffle storage"),(0,r.kt)("p",null,"Gang Scheduling Spark jobs using Apache YuniKorn and Spark Operator"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"  cd analytics/terraform/spark-k8s-operator/examples/cluster-autoscaler/nvme-yunikorn-gang-scheduling\n")),(0,r.kt)("p",null,"Update the variables in Shell script and execute"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"  ./taxi-trip-execute.sh\n")),(0,r.kt)("p",null,"Update YAML file and run the below command"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"  kubectl apply -f nvme-storage-yunikorn-gang-scheduling.yaml\n"))),(0,r.kt)(l.Z,{header:(0,r.kt)("h2",null,(0,r.kt)("span",null,"Example for TPCDS Benchmark test")),mdxType:"CollapsibleContent"},(0,r.kt)("p",null,"Check the pre-requisites in yaml file before running this job."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"cd analytics/terraform/spark-k8s-operator/examples/benchmark\n")),(0,r.kt)("p",null,"Step1: Benchmark test data generation"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl apply -f tpcds-benchmark-data-generation-1t\n")),(0,r.kt)("p",null,"Step2: Execute Benchmark test"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"  kubectl apply -f tpcds-benchmark-1t.yaml\n"))),(0,r.kt)(l.Z,{header:(0,r.kt)("h2",null,(0,r.kt)("span",null,"Cleanup")),mdxType:"CollapsibleContent"},(0,r.kt)("p",null,"This script will cleanup the environment using ",(0,r.kt)("inlineCode",{parentName:"p"},"-target")," option to ensure all the resources are deleted in correct order."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"cd analytics/terraform/spark-k8s-operator && chmod +x cleanup.sh\n./cleanup.sh\n"))),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"To avoid unwanted charges to your AWS account, delete all the AWS resources created during this deployment")))}h.isMDXComponent=!0},1824:(e,a,t)=>{t.d(a,{Z:()=>n});const n=t.p+"assets/images/eks-spark-operator-ca-50c4a6548c280ad97f6c0083ca0324b0.png"},3329:(e,a,t)=>{t.d(a,{Z:()=>n});const n=t.p+"assets/images/eks-spark-operator-karpenter-c55257bc1dc1c98152bea2f8ebcc8bd3.png"},5394:(e,a,t)=>{t.d(a,{Z:()=>n});const n=t.p+"assets/images/spark-operator-6752098849b2e90ded1f19770c70f101.png"}}]);